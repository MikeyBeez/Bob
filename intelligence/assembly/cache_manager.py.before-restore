"""
"""
cache_manager.py - Context caching and optimization module
cache_manager.py - Context caching and optimization module


Handles intelligent caching of context assembly results
Handles intelligent caching of context assembly results
to improve performance and reduce redundant computations.
to improve performance and reduce redundant computations.
Clean API with TTL, invalidation, and cache optimization.
Clean API with TTL, invalidation, and cache optimization.
"""
"""


from typing import Any, Dict, List, Optional, Tuple, Set
from typing import Any, Dict, List, Optional, Tuple, Set
from datetime import datetime, timedelta
from datetime import datetime, timedelta
import json
import json
import hashlib
import hashlib
from dataclasses import dataclass, asdict
from dataclasses import dataclass, asdict
from enum import Enum
from enum import Enum
import weakref
import weakref




class CacheStrategy(Enum):
class CacheStrategy(Enum):
    """Cache eviction strategies."""
    """Cache eviction strategies."""
    LRU = "lru"          # Least Recently Used
    LRU = "lru"          # Least Recently Used
    LFU = "lfu"          # Least Frequently Used
    LFU = "lfu"          # Least Frequently Used
    TTL = "ttl"          # Time To Live only
    TTL = "ttl"          # Time To Live only
    HYBRID = "hybrid"    # Combination of LRU and TTL
    HYBRID = "hybrid"    # Combination of LRU and TTL




@dataclass
@dataclass
class CacheEntry:
class CacheEntry:
    """Represents a cache entry with metadata."""
    """Represents a cache entry with metadata."""
    key: str
    key: str
    value: Any
    value: Any
    created_at: datetime
    created_at: datetime
    last_accessed: datetime
    last_accessed: datetime
    access_count: int
    access_count: int
    ttl_seconds: int
    ttl_seconds: int
    size_estimate: int
    size_estimate: int
    tags: Set[str]
    tags: Set[str]
    
    
    @property
    @property
    def is_expired(self) -> bool:
    def is_expired(self) -> bool:
        """Check if entry has expired."""
        """Check if entry has expired."""
        if self.ttl_seconds <= 0:
        if self.ttl_seconds <= 0:
            return False
            return False
        return datetime.now() > self.created_at + timedelta(seconds=self.ttl_seconds)
        return datetime.now() > self.created_at + timedelta(seconds=self.ttl_seconds)
    
    
    @property
    @property
    def age_seconds(self) -> int:
    def age_seconds(self) -> int:
        """Get entry age in seconds."""
        """Get entry age in seconds."""
        return int((datetime.now() - self.created_at).total_seconds())
        return int((datetime.now() - self.created_at).total_seconds())
    
    
    def touch(self):
    def touch(self):
        """Mark entry as recently accessed."""
        """Mark entry as recently accessed."""
        self.last_accessed = datetime.now()
        self.last_accessed = datetime.now()
        self.access_count += 1
        self.access_count += 1




class CacheManager:
class CacheManager:
    """
    """
    Intelligent caching system for context assembly.
    Intelligent caching system for context assembly.
    
    
    Public API for caching context results with multiple
    Public API for caching context results with multiple
    eviction strategies and intelligent invalidation.
    eviction strategies and intelligent invalidation.
    """
    """
    
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.config = config or {}
        
        
        # Cache configuration
        # Cache configuration
        self.max_entries = self.config.get('max_entries', 1000)
        self.max_entries = self.config.get('max_entries', 1000)
        self.max_memory_mb = self.config.get('max_memory_mb', 100)
        self.max_memory_mb = self.config.get('max_memory_mb', 100)
        self.default_ttl = self.config.get('default_ttl_seconds', 3600)  # 1 hour
        self.default_ttl = self.config.get('default_ttl_seconds', 3600)  # 1 hour
        self.strategy = CacheStrategy(self.config.get('strategy', 'hybrid'))
        self.strategy = CacheStrategy(self.config.get('strategy', 'hybrid'))
        
        
        # Cache storage
        # Cache storage
        self.entries: Dict[str, CacheEntry] = {}
        self.entries: Dict[str, CacheEntry] = {}
        self.tag_index: Dict[str, Set[str]] = {}  # tag -> set of cache keys
        self.tag_index: Dict[str, Set[str]] = {}  # tag -> set of cache keys
        
        
        # Metrics
        # Metrics
        self._metrics = {
        self._metrics = {
            'hits': 0,
            'hits': 0,
            'misses': 0,
            'misses': 0,
            'evictions': 0,
            'evictions': 0,
            'invalidations': 0,
            'invalidations': 0,
            'memory_usage_mb': 0,
            'memory_usage_mb': 0,
            'entries_count': 0
            'entries_count': 0
        }
        }
    
    
    def get(self, key: str, default: Any = None) -> Any:
    def get(self, key: str, default: Any = None) -> Any:
        """
        """
        Retrieve value from cache.
        Retrieve value from cache.
        
        
        Args:
        Args:
            key: Cache key
            key: Cache key
            default: Default value if not found
            default: Default value if not found
            
            
        Returns:
        Returns:
            Cached value or default
            Cached value or default
        """
        """
        if key not in self.entries:
        if key not in self.entries:
            self._metrics['misses'] += 1
            self._metrics['misses'] += 1
            return default
            return default
        
        
        entry = self.entries[key]
        entry = self.entries[key]
        
        
        # Check if expired
        # Check if expired
        if entry.is_expired:
        if entry.is_expired:
            self.invalidate(key)
            self.invalidate(key)
            self._metrics['misses'] += 1
            self._metrics['misses'] += 1
            return default
            return default
        
        
        # Update access info
        # Update access info
        entry.touch()
        entry.touch()
        self._metrics['hits'] += 1
        self._metrics['hits'] += 1
        
        
        return entry.value
        return entry.value
    
    
    def put(self, key: str, value: Any, ttl_seconds: Optional[int] = None, 
    def put(self, key: str, value: Any, ttl_seconds: Optional[int] = None, 
           tags: Optional[Set[str]] = None) -> bool:
           tags: Optional[Set[str]] = None) -> bool:
        """
        """
        Store value in cache.
        Store value in cache.
        
        
        Args:
        Args:
            key: Cache key
            key: Cache key
            value: Value to cache
            value: Value to cache
            ttl_seconds: Time to live (None = default)
            ttl_seconds: Time to live (None = default)
            tags: Tags for grouping and invalidation
            tags: Tags for grouping and invalidation
            
            
        Returns:
        Returns:
            True if stored successfully
            True if stored successfully
        """
        """
        ttl = ttl_seconds or self.default_ttl
        ttl = ttl_seconds or self.default_ttl
        tags = tags or set()
        tags = tags or set()
        
        
        # Estimate size (rough)
        # Estimate size (rough)
        size_estimate = self._estimate_size(value)
        size_estimate = self._estimate_size(value)
        
        
        # Check if we need to evict entries
        # Check if we need to evict entries
        if not self._ensure_space(size_estimate):
        if not self._ensure_space(size_estimate):
            return False
            return False
        
        
        # Remove existing entry if present
        # Remove existing entry if present
        if key in self.entries:
        if key in self.entries:
            self._remove_entry(key)
            self._remove_entry(key)
        
        
        # Create new entry
        # Create new entry
        entry = CacheEntry(
        entry = CacheEntry(
            key=key,
            key=key,
            value=value,
            value=value,
            created_at=datetime.now(),
            created_at=datetime.now(),
            last_accessed=datetime.now(),
            last_accessed=datetime.now(),
            access_count=1,
            access_count=1,
            ttl_seconds=ttl,
            ttl_seconds=ttl,
            size_estimate=size_estimate,
            size_estimate=size_estimate,
            tags=tags
            tags=tags
        )
        )
        
        
        # Store entry
        # Store entry
        self.entries[key] = entry
        self.entries[key] = entry
        
        
        # Update tag index
        # Update tag index
        for tag in tags:
        for tag in tags:
            if tag not in self.tag_index:
            if tag not in self.tag_index:
                self.tag_index[tag] = set()
                self.tag_index[tag] = set()
            self.tag_index[tag].add(key)
            self.tag_index[tag].add(key)
        
        
        # Update metrics
        # Update metrics
        self._update_metrics()
        self._update_metrics()
        
        
        return True
        return True
    
    
    def invalidate(self, key: str) -> bool:
    def invalidate(self, key: str) -> bool:
        """
        """
        Remove specific entry from cache.
        Remove specific entry from cache.
        
        
        Args:
        Args:
            key: Cache key to remove
            key: Cache key to remove
            
            
        Returns:
        Returns:
            True if entry was removed
            True if entry was removed
        """
        """
        if key in self.entries:
        if key in self.entries:
            self._remove_entry(key)
            self._remove_entry(key)
            self._metrics['invalidations'] += 1
            self._metrics['invalidations'] += 1
            self._update_metrics()
            self._update_metrics()
            return True
            return True
        return False
        return False
    
    
    def invalidate_by_tag(self, tag: str) -> int:
    def invalidate_by_tag(self, tag: str) -> int:
        """
        """
        Remove all entries with specified tag.
        Remove all entries with specified tag.
        
        
        Args:
        Args:
            tag: Tag to match
            tag: Tag to match
            
            
        Returns:
        Returns:
            Number of entries removed
            Number of entries removed
        """
        """
        if tag not in self.tag_index:
        if tag not in self.tag_index:
            return 0
            return 0
        
        
        keys_to_remove = list(self.tag_index[tag])
        keys_to_remove = list(self.tag_index[tag])
        count = 0
        count = 0
        
        
        for key in keys_to_remove:
        for key in keys_to_remove:
            if self.invalidate(key):
            if self.invalidate(key):
                count += 1
                count += 1
        
        
        return count
        return count
    
    
    def generate_key(self, query: str, context_config: Dict[str, Any]) -> str:
    def generate_key(self, query: str, context_config: Dict[str, Any]) -> str:
        """
        """
        Generate cache key from query and configuration.
        Generate cache key from query and configuration.
        
        
        Args:
        Args:
            query: Context query
            query: Context query
            context_config: Configuration parameters
            context_config: Configuration parameters
            
            
        Returns:
        Returns:
            Unique cache key
            Unique cache key
        """
        """
        # Create deterministic key from query and config
        # Create deterministic key from query and config
        key_data = {
        key_data = {
            'query': query.strip().lower(),
            'query': query.strip().lower(),
            'config': sorted(context_config.items()) if context_config else []
            'config': sorted(context_config.items()) if context_config else []
        }
        }
        
        
        key_str = json.dumps(key_data, sort_keys=True)
        key_str = json.dumps(key_data, sort_keys=True)
        key_hash = hashlib.sha256(key_str.encode()).hexdigest()[:16]
        key_hash = hashlib.sha256(key_str.encode()).hexdigest()[:16]
        
        
        return f"context_{key_hash}"
        return f"context_{key_hash}"
    
    
    def _estimate_size(self, value: Any) -> int:
    def _estimate_size(self, value: Any) -> int:
        """Estimate memory size of value in bytes."""
        """Estimate memory size of value in bytes."""
        if isinstance(value, str):
        if isinstance(value, str):
            return len(value.encode('utf-8'))
            return len(value.encode('utf-8'))
        elif isinstance(value, (int, float)):
        elif isinstance(value, (int, float)):
            return 8
            return 8
        elif isinstance(value, dict):
        elif isinstance(value, dict):
            return sum(self._estimate_size(k) + self._estimate_size(v) 
            return sum(self._estimate_size(k) + self._estimate_size(v) 
                      for k, v in value.items())
                      for k, v in value.items())
        elif isinstance(value, (list, tuple)):
        elif isinstance(value, (list, tuple)):
            return sum(self._estimate_size(item) for item in value)
            return sum(self._estimate_size(item) for item in value)
        else:
        else:
            # Rough estimate for other types
            # Rough estimate for other types
            return len(str(value)) * 2
            return len(str(value)) * 2
    
    
    def _remove_entry(self, key: str):
    def _remove_entry(self, key: str):
        """Remove entry and update indexes."""
        """Remove entry and update indexes."""
        if key not in self.entries:
        if key not in self.entries:
            return
            return
        
        
        entry = self.entries[key]
        entry = self.entries[key]
        
        
        # Remove from tag indexes
        # Remove from tag indexes
        for tag in entry.tags:
        for tag in entry.tags:
            if tag in self.tag_index:
            if tag in self.tag_index:
                self.tag_index[tag].discard(key)
                self.tag_index[tag].discard(key)
                if not self.tag_index[tag]:
                if not self.tag_index[tag]:
                    del self.tag_index[tag]
                    del self.tag_index[tag]
        
        
        # Remove entry
        # Remove entry
        del self.entries[key]
        del self.entries[key]
    
    
    def _ensure_space(self, size_needed: int) -> bool:
    def _ensure_space(self, size_needed: int) -> bool:
        """Ensure cache has space for new entry."""
        """Ensure cache has space for new entry."""
        # Check entry count limit
        # Check entry count limit
        if len(self.entries) >= self.max_entries:
        if len(self.entries) >= self.max_entries:
            if not self._evict_entries(1):
            if not self._evict_entries(1):
                return False
                return False
        
        
        # Check memory limit (rough estimate)
        # Check memory limit (rough estimate)
        current_memory = sum(entry.size_estimate for entry in self.entries.values())
        current_memory = sum(entry.size_estimate for entry in self.entries.values())
        max_memory_bytes = self.max_memory_mb * 1024 * 1024
        max_memory_bytes = self.max_memory_mb * 1024 * 1024
        
        
        if current_memory + size_needed > max_memory_bytes:
        if current_memory + size_needed > max_memory_bytes:
            # Try to free up space
            # Try to free up space
            target_to_free = (current_memory + size_needed) - max_memory_bytes
            target_to_free = (current_memory + size_needed) - max_memory_bytes
            if not self._evict_by_size(target_to_free):
            if not self._evict_by_size(target_to_free):
                return False
                return False
        
        
        return True
        return True
    
    
    def _evict_entries(self, count: int) -> bool:
    def _evict_entries(self, count: int) -> bool:
        """Evict entries based on current strategy."""
        """Evict entries based on current strategy."""
        if self.strategy == CacheStrategy.LRU:
        if self.strategy == CacheStrategy.LRU:
            return self._evict_lru_entries(count)
            return self._evict_lru_entries(count)
        elif self.strategy == CacheStrategy.LFU:
        elif self.strategy == CacheStrategy.LFU:
            return self._evict_lfu_entries(count)
            return self._evict_lfu_entries(count)
        elif self.strategy == CacheStrategy.TTL:
        elif self.strategy == CacheStrategy.TTL:
            return self._evict_expired_entries()
            return self._evict_expired_entries()
        else:  # HYBRID
        else:  # HYBRID
            # First try expired, then LRU
            # First try expired, then LRU
            self._evict_expired_entries()
            self._evict_expired_entries()
            return self._evict_lru_entries(count)
            return self._evict_lru_entries(count)
    
    
    def _evict_lru_entries(self, count: int) -> bool:
    def _evict_lru_entries(self, count: int) -> bool:
        """Evict least recently used entries."""
        """Evict least recently used entries."""
        if not self.entries:
        if not self.entries:
            return False
            return False
        
        
        # Sort by last_accessed (oldest first)
        # Sort by last_accessed (oldest first)
        sorted_entries = sorted(
        sorted_entries = sorted(
            self.entries.items(),
            self.entries.items(),
            key=lambda x: x[1].last_accessed
            key=lambda x: x[1].last_accessed
        )
        )
        
        
        evicted = 0
        evicted = 0
        for key, entry in sorted_entries:
        for key, entry in sorted_entries:
            if evicted >= count:
            if evicted >= count:
                break
                break
            self._remove_entry(key)
            self._remove_entry(key)
            evicted += 1
            evicted += 1
        
        
        self._metrics['evictions'] += evicted
        self._metrics['evictions'] += evicted
        return evicted > 0
        return evicted > 0
    
    
    def _evict_lfu_entries(self, count: int) -> bool:
    def _evict_lfu_entries(self, count: int) -> bool:
        """Evict least frequently used entries."""
        """Evict least frequently used entries."""
        if not self.entries:
        if not self.entries:
            return False
            return False
        
        
        # Sort by access_count (lowest first)
        # Sort by access_count (lowest first)
        sorted_entries = sorted(
        sorted_entries = sorted(
            self.entries.items(),
            self.entries.items(),
            key=lambda x: x[1].access_count
            key=lambda x: x[1].access_count
        )
        )
        
        
        evicted = 0
        evicted = 0
        for key, entry in sorted_entries:
        for key, entry in sorted_entries:
            if evicted >= count:
            if evicted >= count:
                break
                break
            self._remove_entry(key)
            self._remove_entry(key)
            evicted += 1
            evicted += 1
        
        
        self._metrics['evictions'] += evicted
        self._metrics['evictions'] += evicted
        return evicted > 0
        return evicted > 0
    
    
    def _evict_expired_entries(self) -> bool:
    def _evict_expired_entries(self) -> bool:
        """Remove all expired entries."""
        """Remove all expired entries."""
        expired_keys = [key for key, entry in self.entries.items() if entry.is_expired]
        expired_keys = [key for key, entry in self.entries.items() if entry.is_expired]
        
        
        for key in expired_keys:
        for key in expired_keys:
            self._remove_entry(key)
            self._remove_entry(key)
        
        
        evicted = len(expired_keys)
        evicted = len(expired_keys)
        self._metrics['evictions'] += evicted
        self._metrics['evictions'] += evicted
        return evicted > 0
        return evicted > 0
    
    
    def _evict_by_size(self, target_bytes: int) -> bool:
    def _evict_by_size(self, target_bytes: int) -> bool:
        """Evict entries to free up target bytes."""
        """Evict entries to free up target bytes."""
        # Sort by size (largest first) and age (oldest first)
        # Sort by size (largest first) and age (oldest first)
        sorted_entries = sorted(
        sorted_entries = sorted(
            self.entries.items(),
            self.entries.items(),
            key=lambda x: (x[1].size_estimate, x[1].age_seconds),
            key=lambda x: (x[1].size_estimate, x[1].age_seconds),
            reverse=True
            reverse=True
        )
        )
        
        
        freed_bytes = 0
        freed_bytes = 0
        evicted = 0
        evicted = 0
        
        
        for key, entry in sorted_entries:
        for key, entry in sorted_entries:
            if freed_bytes >= target_bytes:
            if freed_bytes >= target_bytes:
                break
                break
            
            
            freed_bytes += entry.size_estimate
            freed_bytes += entry.size_estimate
            self._remove_entry(key)
            self._remove_entry(key)
            evicted += 1
            evicted += 1
        
        
        self._metrics['evictions'] += evicted
        self._metrics['evictions'] += evicted
        return freed_bytes >= target_bytes
        return freed_bytes >= target_bytes
    
    
    def _update_metrics(self):
    def _update_metrics(self):
        """Update cache metrics."""
        """Update cache metrics."""
        self._metrics['entries_count'] = len(self.entries)
        self._metrics['entries_count'] = len(self.entries)
        self._metrics['memory_usage_mb'] = (
        self._metrics['memory_usage_mb'] = (
            sum(entry.size_estimate for entry in self.entries.values()) / (1024 * 1024)
            sum(entry.size_estimate for entry in self.entries.values()) / (1024 * 1024)
        )
        )
    
    
    def _get_oldest_entry_age(self) -> int:
    def _get_oldest_entry_age(self) -> int:
        """Get age of oldest entry in seconds."""
        """Get age of oldest entry in seconds."""
        if not self.entries:
        if not self.entries:
            return 0
            return 0
        return max(entry.age_seconds for entry in self.entries.values())
        return max(entry.age_seconds for entry in self.entries.values())
    
    
    def _get_average_entry_size(self) -> float:
    def _get_average_entry_size(self) -> float:
        """Get average entry size in bytes."""
        """Get average entry size in bytes."""
        if not self.entries:
        if not self.entries:
            return 0.0
            return 0.0
        return sum(entry.size_estimate for entry in self.entries.values()) / len(self.entries)
        return sum(entry.size_estimate for entry in self.entries.values()) / len(self.entries)
    
    
    def get_metrics(self) -> Dict[str, Any]:
    def get_metrics(self) -> Dict[str, Any]:
        """Get cache performance metrics."""
        """Get cache performance metrics."""
        total_requests = self._metrics['hits'] + self._metrics['misses']
        total_requests = self._metrics['hits'] + self._metrics['misses']
        hit_rate = self._metrics['hits'] / max(1, total_requests) * 100
        hit_rate = self._metrics['hits'] / max(1, total_requests) * 100
        
        
        return {
        return {
            **self._metrics,
            **self._metrics,
            'hit_rate_percent': hit_rate,
            'hit_rate_percent': hit_rate,
            'oldest_entry_age_seconds': self._get_oldest_entry_age(),
            'oldest_entry_age_seconds': self._get_oldest_entry_age(),
            'average_entry_size_bytes': self._get_average_entry_size(),
            'average_entry_size_bytes': self._get_average_entry_size(),
            'tags_count': len(self.tag_index)
            'tags_count': len(self.tag_index)
        }
        }
